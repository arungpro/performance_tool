/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
 */
'use strict';

function MongodbProbe(agent) {
  this.agent = agent;

  this.packages = ['mongodb'];
}

exports.MongodbProbe = MongodbProbe;

MongodbProbe.prototype.attach = function(obj) {
  var self = this;
  var proxy = self.agent.proxy;
  var profiler = self.agent.profiler;

  if(obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;

  if ('instrument' in obj) {
    // driver 2.x with APM API
    self.agent.on('destroy', function() {
      if(obj.__appdynamicsProbeAttached__) {
        delete obj.__appdynamicsProbeAttached__;
      }
    });

    var serverPool;
    var opQueue = {};
    var listener = obj.instrument();
    var supportedCommands = ['find', 'cursor', 'insert', 'update', 'remove'];

    // expose opQueue for integation testing
    self.__opQueue = opQueue;

    listener.on('started', function(event) {
      var requestId = event.requestId, request;
      if (supportedCommands.indexOf(event.commandName) < 0) return;
      if (event.connectionId) {
        var cid = event.connectionId;
        if (typeof(cid) === 'string')
          serverPool = [cid];
        else
          serverPool = [cid.host + ':' + cid.port];
      }
      if (serverPool) {
        if (!opQueue[requestId]) {
          opQueue[requestId] = {
            time: profiler.time(),
            serverPool: serverPool
          };
        }
        request = opQueue[requestId];
        var commandArgs = {
          databaseName: event.databaseName,
          collectionName: event.command[event.commandName],
          query: profiler.sanitize(JSON.stringify(event.command.filter)),
          queryOptions: Object.keys(event.command).reduce(function(result, key) {
            if (key != event.commandName && key != 'filter') {
              result[key] = event.command[key];
            }
            return result;
          }, {}),
          numberToSkip: event.command.skip,
          numberToReturn: event.command.limit
        };

        request.exitCall = self.createExitCall(request.time, serverPool,
                                               event.commandName, commandArgs,
                                               event.commandName == 'find' ? 'read' : 'write',
                                               profiler.stackTrace());
      }
    });

    listener.on('succeeded', function(event) {
      var requestId = event.requestId, request = opQueue[requestId];
      if (request) {
        self.addExitCall(request.time, request.exitCall);
        opQueue[requestId] = undefined;
      }
    });

    listener.on('failed', function(event) {
      var requestId = event.requestId, request = opQueue[requestId];
      if (request) {
        self.addExitCall(event.time, event.exitCall, event.failure);
        opQueue[requestId] = undefined;
      }
    });
  } else if (!('version' in obj)) {
    // driver 2.x w/out APM API
    var commands = ['cursor', 'insert', 'update', 'remove'];

    // queries via a cursor find command must be reported after they complete:
    proxy.around(obj.Cursor.prototype, '_next', function(obj, args, locals) {
      locals.methodHasCb = proxy.callback(args, -1, function(obj_, args) {
        complete(args, obj);
      });
    }, after);

    commands.forEach(function(command) {
      var commandName = command == 'cursor' ? 'find' : command;

      function withoutAPMBeforeHandler(obj, args, locals) {
        var commandArgs;
        var category;
        var opts = {};
        var query = '';

        if (command == 'cursor' && !args[1].find) return;

        var serverPool = self.getServerPool(obj.s);
        if (serverPool.length) {
          opts = {};
          if (args[1] && args[1].query) {
            query = profiler.sanitize(JSON.stringify(args[1].query));
            Object.keys(args[1]).forEach(function(key) {
              if (key !== 'query') {
                opts[key] = args[1][key];
              }
            });
          }

          commandArgs = {
            databaseName: args[0].split('.')[0],
            collectionName: args[0].split('.')[1],
            query: query,
            queryOptions: opts,
            numberToSkip: opts.skip,
            numberToReturn: opts.limit
          };

          if(obj.s.auths && obj.s.auths.length > 0) {
            commandArgs.auth = obj.s.auths[0];
          }

          if (commandName == 'find') {
            category = "read";
          } else {
            category = "write";
          }

          locals.time = profiler.time();

          locals.exitCall = self.createExitCall(locals.time, serverPool,
                                         commandName, commandArgs, category,
                                         profiler.stackTrace());
        }

        if (commandName == 'find') {
          // stash exit call for later processing
          args[1].__appd_exitcall_info = {
            time: locals.time,
            exitCall: locals.exitCall
          };
        } else {
          locals.methodHasCb = proxy.callback(args, -1, function(obj, args) {
            self.addExitCall(locals.time, locals.exitCall, args);
          });
        }
      }

      function withoutAPMAfterHandler(obj, args, ret, locals) {
        if (locals.exitCall.command === 'find') return;
        if (locals.methodHasCb) return;
        if (!ret || !ret.__appdynamicsIsPromiseResult__)
          self.addExitCall(locals.time, locals.exitCall, args);
        else if (ret.error)
          self.addExitCall(locals.time, locals.exitCall, ret.error);
        else
          self.addExitCall(locals.time, locals.exitCall);
      }

      proxy.around(obj.Server.prototype, command, withoutAPMBeforeHandler, withoutAPMAfterHandler);
      proxy.around(obj.ReplSet.prototype, command, withoutAPMBeforeHandler, withoutAPMAfterHandler);
    });
  } else if (obj.Db && obj.Db.prototype && obj.Db.prototype._executeQueryCommand) {
    // driver 1.x
    var internalCommands = [
      '_executeQueryCommand',
      '_executeInsertCommand',
      '_executeUpdateCommand',
      '_executeRemoveCommand'
    ];

    var commandMap = {
      '_executeQueryCommand': 'find',
      '_executeInsertCommand': 'insert',
      '_executeUpdateCommand': 'update',
      '_executeRemoveCommand': 'remove'
    };

    internalCommands.forEach(function(internalCommand) {
      var commandName = commandMap[internalCommand] || internalCommand;

      proxy.around(obj.Db.prototype, internalCommand, function(obj, args, locals) {
        var command = (args && args.length > 0) ? args[0] : undefined;
        var commandArgs;
        locals.driver = '1.x';

        if(command && command.db) {
          var serverPool = self.getServerPool(command.db);
          var category;

          if (serverPool.length) {
            commandArgs = {
              databaseName: command.db.databaseName,
              collectionName: command.collectionName.split('.')[1],
              query: command.query ? profiler.sanitize(JSON.stringify(command.query)) : '',
              queryOptions: command.queryOptions,
              numberToSkip: command.numberToSkip,
              numberToReturn: command.numberToReturn
            };

            if(command.db.auths && command.db.auths.length > 0) {
              commandArgs.auth = command.db.auths[0];
            }

            if(internalCommand === '_executeQueryCommand') {
              category = "read";
            }
            else {
              category = "write";
            }

            locals.time = profiler.time();

            locals.exitCall = self.createExitCall(locals.time, serverPool,
                                           commandName, commandArgs, category,
                                           profiler.stackTrace());
          }
        }

        locals.methodHasCb = proxy.callback(args, -1, function(obj, args) {
          complete(args, locals, '1.x');
        });
      }, after);
    });
  }

  function complete(err, obj, driver) {
    var exitCallInfoHolder;
    if (driver && driver == '1.x') {
      exitCallInfoHolder = obj;
    } else {
      if (!obj.cursorState.dead && (!obj.cursorState.notified || !(obj.cursorState.documents.length == 0))) return;
      if (!obj.cmd || !obj.cmd.__appd_exitcall_info) return;
      exitCallInfoHolder = obj.cmd.__appd_exitcall_info;
    }

    if (!exitCallInfoHolder.exitCall) return;
    if (!exitCallInfoHolder.time) return;
    self.addExitCall(exitCallInfoHolder.time, exitCallInfoHolder.exitCall, err);
  }

  function after (obj, args, ret, locals) {
    if (locals.methodHasCb) return;
    if (locals.driver == '1.x')
      obj = locals;
    if (!ret || !ret.__appdynamicsIsPromiseResult__)
      complete(null, obj, locals.driver);
    else if (ret.error)
      complete(ret.error, obj, locals.driver);
    else {
      complete(null, obj, locals.driver);
    }
  }
};

MongodbProbe.prototype.getServerPool = function(db) {
  var serverPool = [];

  var serverConfig = db && (db.serverConfig || db.serverDetails || db);

  if(serverConfig) {
    if(serverConfig.s && serverConfig.s.host && serverConfig.s.port) {
      serverPool.push(serverConfig.s.host + ':' + serverConfig.s.port);
    }
    else if(serverConfig.host && serverConfig.port) {
      serverPool.push(serverConfig.host + ':' + serverConfig.port);
    }
    else if(Array.isArray(serverConfig.servers)) {
      serverConfig.servers.forEach(function(server) {
        serverPool.push(server.host + ':' + server.port);
      });
    }
  }

  if (serverPool.length) {
    serverPool = serverPool.sort();
  }

  return serverPool;
};

MongodbProbe.prototype.createExitCall = function(time, serverPool, commandName, commandArgs, category, stackTrace) {
  var address = serverPool[serverPool.length - 1];

  var supportedProperties = {
    'HOST': address.split(':')[0],
    'PORT': address.split(':')[1],
    'DATABASE': commandArgs.databaseName
  };

  return this.agent.profiler.createExitCall(time, {
    exitType: 'EXIT_CUSTOM',
    exitSubType: 'Mongo DB',
    backendName: 'MongoDB',
    configType: 'Mongodb',
    supportedProperties: supportedProperties,
    category: category,
    command: commandName,
    commandArgs: commandArgs,
    stackTrace: stackTrace,
    vendor: "MONGODB"
  });
};

MongodbProbe.prototype.addExitCall = function(time, exitCall, args) {
  var self = this;
  if(!time || !time.done()) return;

  var error = self.agent.proxy.getErrorObject(args);
  var profiler = self.agent.profiler;

  if (exitCall) {
    profiler.addExitCall(time, exitCall, error);
  }
};
